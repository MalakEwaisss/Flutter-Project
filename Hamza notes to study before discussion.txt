================================================================================
HAMZA NOTES TO STUDY BEFORE DISCUSSION - FLUTTER PROJECT IMPLEMENTATION
================================================================================

This document explains all the code we wrote, why we wrote it, and how it works.
Study this carefully for your 50-grade discussion!


================================================================================
PART 1: CONFIGURATION UPDATES
================================================================================

FILE: lib/config/app_enums.dart
LINE: 1

WHAT: Added "booking" to the AppPage enum
ENUM VALUES: home, trips, profile, tripDetails, booking

WHY WE DID THIS:
- We need a new route for the Booking Summary screen
- The enum is used in main.dart switch statement to decide which screen to show
- When user clicks "Book Now", we navigate to AppPage.booking

HOW IT WORKS:
- Enum is like a list of choices (like a menu)
- main.dart checks which AppPage is selected and shows corresponding screen
- This is our custom navigation system (instead of using GoRouter)


================================================================================
PART 2: PACKAGE DEPENDENCIES
================================================================================

FILE: pubspec.yaml
LINE: 13

WHAT: Added "http: ^1.1.0" package

WHY WE DID THIS:
- Required for Weather Widget to fetch weather data from API
- This is the http package mentioned in Lecture 5
- Without it, we can't make HTTP requests to external APIs

HOW IT WORKS:
- pubspec.yaml is like a shopping list of packages we need
- When you run "flutter pub get", Flutter downloads and installs the http package
- Then we can use "import 'package:http/http.dart' as http;" in our code


================================================================================
PART 3: FLIGHT INFO WIDGET
================================================================================

FILE: lib/widgets/flight_info_card.dart
LINES: 1-210 (entire file)

WHAT: A reusable widget that displays flight information

WHY WE CREATED THIS FILE:
- Separates flight display logic into its own widget (clean code)
- Can be reused anywhere in the app
- Makes code organized and easier to maintain

HOW IT WORKS:
1. Takes trip data as input (via constructor)
2. Extracts flight info from trip: airline, aircraft, class, price
3. Simulates flight times (departure/arrival) - in real app, these would come from API
4. Displays everything in a nice card with icons and styling

KEY CONCEPTS:
- Widget Composition: This widget is built using smaller widgets (Row, Column, Text, Icon)
- StatelessWidget: Doesn't change over time (just displays data)
- Constructor parameters: "required this.trip" means you MUST pass trip data when creating this widget


================================================================================
PART 4: WEATHER WIDGET (LECTURE 5 PATTERN - MOST IMPORTANT!)
================================================================================

FILE: lib/widgets/weather_widget.dart
LINES: 50-83 (fetchWeather method)
LINES: 149-297 (FutureBuilder)

WHAT: Widget that fetches and displays weather using HTTP + FutureBuilder

WHY THIS IS IMPORTANT:
- This implements Lecture 5 pattern: HTTP requests with FutureBuilder
- Shows how to handle async operations (things that take time)
- Demonstrates API integration

HOW fetchWeather() WORKS (Lines 50-83):
1. Extracts city name from location (e.g., "Bali" from "Bali, Indonesia")
2. Builds API URL with city name and API key
3. Uses http.get(url) to make HTTP GET request (this takes time!)
4. Waits for response (await keyword)
5. If successful (status code 200), parses JSON response
6. Extracts temperature, condition, humidity from JSON
7. Returns formatted data as Map

WHY IT'S "async" AND RETURNS "Future":
- HTTP requests take time (network delay)
- "async" means this function can wait without freezing the app
- "Future" is a promise that data will arrive eventually
- Without async/await, the app would freeze while waiting

HOW FutureBuilder WORKS (Lines 149-297):
FutureBuilder is a widget that:
1. Takes a Future (our fetchWeather method)
2. Checks connectionState:
   - ConnectionState.waiting: Shows loading spinner (while request is in progress)
   - ConnectionState.done: Shows data or error
3. Rebuilds UI automatically when Future completes
4. Uses snapshot.data to access the result

WHY WE USE FutureBuilder:
- Handles loading state (shows spinner)
- Handles error state (shows error message)
- Handles success state (shows weather data)
- All in one widget - very convenient!

API SETUP:
- Uses OpenWeatherMap free API (no credit card needed)
- Get free API key at openweathermap.org
- Replace "YOUR_API_KEY_HERE" on line 35 with your actual key
- Free tier: 1,000 calls per day (enough for testing)


================================================================================
PART 5: TRIP DETAILS SCREEN WITH TABS
================================================================================

FILE: lib/screens/trip_details_screen.dart
LINES: 30 (_selectedTab state variable)
LINES: 154-158 (_selectTab method)
LINES: 160-198 (_buildTabButton method)
LINES: 414-427 (Tab buttons in UI)
LINES: 436-441 (Content switching)

WHAT: Screen with tabs (Overview, Flight, Weather) using custom buttons

WHY WE DID THIS:
- User wants to see different information about the trip
- Tabs organize content into sections
- We chose custom buttons (Option B) instead of TabBar for more control

HOW TABS WORK WITH setState:
1. We store current tab in _selectedTab variable (line 30): 'overview', 'flight', or 'weather'
2. When user taps a button, _selectTab() is called (line 154)
3. _selectTab() uses setState() to update _selectedTab (line 155-157)
4. setState() triggers widget rebuild
5. During rebuild, we check _selectedTab value (line 436-441)
6. We show different content based on which tab is selected:
   - If 'overview': Shows _buildOverviewContent()
   - If 'flight': Shows FlightInfoCard widget
   - If 'weather': Shows WeatherWidget

WHY setState:
- setState() tells Flutter "hey, something changed, rebuild the UI"
- Without setState, UI wouldn't update when tab changes
- This is basic state management in Flutter

HOW _buildTabButton WORKS (Lines 160-198):
- Creates a button widget
- Checks if this tab is selected (line 166: isSelected = _selectedTab == tabName)
- Changes color based on selection (line 173: blue if selected, transparent if not)
- When tapped, calls _selectTab() to change the selected tab


================================================================================
PART 6: FAVORITE FUNCTIONALITY
================================================================================

FILE: lib/screens/trip_details_screen.dart
LINES: 33-34 (_isFavorited and _isCheckingFavorite state)
LINES: 42-44 (initState calls _checkFavoriteStatus)
LINES: 52-80 (_checkFavoriteStatus method)
LINES: 90-152 (_toggleFavorite method)
LINES: 380-388 (Favorite button in UI)

WHAT: Allows users to favorite/unfavorite trips

WHY WE DID THIS:
- Implements interactivity requirement (6 marks in grading)
- Users can save trips they like
- Data is stored in Supabase (data persistence - 8 marks)

HOW _checkFavoriteStatus WORKS (Lines 52-80):
1. Checks if user is logged in
2. Queries Supabase 'favorites' table for this trip
3. Uses .eq() to filter by user_id and trip_id
4. If found, sets _isFavorited = true
5. Updates UI with setState()

HOW _toggleFavorite WORKS (Lines 90-152):
1. Checks if user is logged in (shows message if not)
2. Optimistic update: Changes _isFavorited immediately using setState (line 102-104)
3. If adding to favorites:
   - Inserts new row into Supabase 'favorites' table (line 109-117)
   - Shows success message
4. If removing from favorites:
   - Deletes row from Supabase using .delete() (line 127-131)
   - Shows removed message
5. If error occurs, reverts the change (line 141-144)

WHY OPTIMISTIC UPDATE:
- Updates UI immediately (feels fast)
- Then syncs with database
- If error, reverts the change
- Better user experience

DATABASE STRUCTURE:
Supabase 'favorites' table needs:
- user_id (string)
- trip_id (string)
- trip_name, trip_location, trip_price, trip_image (for displaying)
- favorited_at (timestamp)


================================================================================
PART 7: BOOKING SUMMARY SCREEN
================================================================================

FILE: lib/screens/booking_summary_screen.dart
LINES: 33-34 (TextEditingController for form inputs)
LINES: 38-44 (dispose method)
LINES: 55-131 (_handleConfirmBooking method)
LINES: 138-213 (_showSuccessDialog method)

WHAT: Final screen where users confirm their booking

WHY WE CREATED THIS FILE:
- Separates booking confirmation from trip details (better organization)
- Allows user to review before finalizing
- Collects additional info (guests count, special requests)

HOW TextEditingController WORKS (Lines 33-34):
- TextEditingController manages text input fields
- _guestsController manages "Number of Guests" field
- _specialRequestsController manages "Special Requests" field
- We must dispose() them when widget is destroyed (lines 38-44) to prevent memory leaks

HOW _handleConfirmBooking WORKS (Lines 55-131):
1. VALIDATION: Checks if user is logged in (line 57)
2. VALIDATION: Checks if guests field is filled (line 69)
3. VALIDATION: Checks if guests is a valid number >= 1 (line 80)
4. Calculates total price = base price Ã— number of guests (line 95-96)
5. Saves to Supabase 'bookings' table (line 99-108):
   - user_id, trip_id, trip_name, location
   - number_of_guests, special_requests
   - total_price, booking_date
6. Shows success dialog (line 112)
7. Navigates to home (line 115)

WHY VALIDATION:
- Prevents invalid data (e.g., negative guests, empty fields)
- Better user experience (shows helpful error messages)
- Required for "App Functionality" marks (10 marks)

HOW _showSuccessDialog WORKS (Lines 138-213):
- Uses showDialog() to display a modal dialog
- Shows success icon, message, and OK button
- barrierDismissible: false means user must tap OK (can't tap outside)
- When OK is pressed, dialog closes and navigation happens

DATABASE STRUCTURE:
Supabase 'bookings' table needs:
- user_id (string)
- trip_id, trip_name, location (string)
- number_of_guests (integer)
- special_requests (text, nullable)
- total_price (integer)
- booking_date (timestamp)


================================================================================
PART 8: MAIN APP UPDATES
================================================================================

FILE: lib/main.dart
LINES: 11 (import statement)
LINES: 118-126 (booking case in switch statement)

WHAT: Added routing for booking screen

WHY WE DID THIS:
- Completes the navigation flow: Trip Details â†’ Book Now â†’ Booking Summary
- Integrates new screen into existing navigation system

HOW IT WORKS:
1. Import BookingSummaryScreen (line 11)
2. Add case AppPage.booking in switch statement (lines 118-126)
3. When _currentPage == AppPage.booking, shows BookingSummaryScreen
4. Passes trip data and navigateTo function via constructor

WHY THIS PATTERN:
- Uses our custom enum-based navigation (not GoRouter)
- Data passed via constructor (not global state)
- Matches existing architecture pattern


================================================================================
KEY CONCEPTS EXPLAINED SIMPLY
================================================================================

1. setState():
   - Tells Flutter "something changed, please rebuild the UI"
   - Only works inside StatefulWidget
   - When you call setState(), Flutter rebuilds the widget

2. async/await:
   - Used for operations that take time (HTTP requests, database queries)
   - async = "this function can wait"
   - await = "wait here until this finishes"
   - Without it, app would freeze while waiting

3. Future:
   - A promise that data will arrive eventually
   - Like ordering food - you get a receipt (Future) now, food comes later

4. FutureBuilder:
   - Widget that automatically handles Future states
   - Shows loading â†’ then shows data or error
   - Very useful for API calls

5. StatefulWidget vs StatelessWidget:
   - StatelessWidget: Doesn't change (like a photo)
   - StatefulWidget: Can change (like a video player with play/pause)

6. Widget Composition:
   - Building big widgets from smaller widgets
   - Like building a house from bricks

7. Constructor Parameters:
   - Way to pass data when creating a widget
   - Like giving ingredients to a recipe

8. Supabase Operations:
   - .insert(): Add new row
   - .select(): Read rows
   - .delete(): Remove rows
   - .eq(): Filter (equals)
   - .maybeSingle(): Get one row or null


================================================================================
GRADING CRITERIA COVERAGE
================================================================================

âœ… Flutter UI & Widgets (5 marks): Scaffold, AppBar, Column/Row, ListView, images
âœ… APIs and Packages (2 marks): http package in pubspec.yaml
âœ… App Functionality (10 marks): All features work, validation implemented
âœ… Navigation & Structure (4 marks): Multiple screens, organized structure
âœ… Data Persistence (8 marks): Supabase for favorites and bookings (CRUD)
âœ… Responsiveness & UX (4 marks): Responsive layouts, dark mode
âœ… Interactivity (6 marks): Favorite trips functionality
âœ… Code Quality (2 marks): Clean, readable code


================================================================================
IMPORTANT NOTES FOR DISCUSSION
================================================================================

1. Weather API: Get free key from openweathermap.org, replace "YOUR_API_KEY_HERE"

2. Supabase Tables: Create 'favorites' and 'bookings' tables with columns listed above

3. State Management: We use setState (not Riverpod) as per requirements

4. Navigation: Custom enum-based system (not GoRouter) as per requirements

5. Data Flow: Data passed via constructors (not global state)

6. Architecture: Follows widget composition pattern (reusable widgets)


================================================================================
END OF NOTES
================================================================================

Good luck with your discussion! Study these concepts well! ðŸš€
