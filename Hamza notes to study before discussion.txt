================================================================================
HAMZA NOTES TO STUDY BEFORE DISCUSSION - FLUTTER PROJECT IMPLEMENTATION
================================================================================

This document explains all the code we wrote, why we wrote it, and how it works.
Study this carefully for your 50-grade discussion!


================================================================================
PART 1: CONFIGURATION UPDATES
================================================================================

FILE: lib/config/app_enums.dart
LINE: 1

WHAT: Added "booking" to the AppPage enum
ENUM VALUES: home, trips, profile, tripDetails, booking

WHY WE DID THIS:
- We need a new route for the Booking Summary screen
- The enum is used in main.dart switch statement to decide which screen to show
- When user clicks "Book Now", we navigate to AppPage.booking

HOW IT WORKS:
- Enum is like a list of choices (like a menu)
- main.dart checks which AppPage is selected and shows corresponding screen
- This is our custom navigation system (instead of using GoRouter)


================================================================================
PART 2: PACKAGE DEPENDENCIES
================================================================================

FILE: pubspec.yaml
LINE: 13

WHAT: Added "http: ^1.1.0" package

WHY WE DID THIS:
- Required for Weather Widget to fetch weather data from API
- This is the http package mentioned in Lecture 5
- Without it, we can't make HTTP requests to external APIs

HOW IT WORKS:
- pubspec.yaml is like a shopping list of packages we need
- When you run "flutter pub get", Flutter downloads and installs the http package
- Then we can use "import 'package:http/http.dart' as http;" in our code


================================================================================
PART 3: FLIGHT INFO WIDGET
================================================================================

FILE: lib/widgets/flight_info_card.dart
LINES: 1-210 (entire file)

WHAT: A reusable widget that displays flight information

WHY WE CREATED THIS FILE:
- Separates flight display logic into its own widget (clean code)
- Can be reused anywhere in the app
- Makes code organized and easier to maintain

HOW IT WORKS:
1. Takes trip data as input (via constructor)
2. Extracts flight info from trip: airline, aircraft, class, price
3. Simulates flight times (departure/arrival) - in real app, these would come from API
4. Displays everything in a nice card with icons and styling

KEY CONCEPTS:
- Widget Composition: This widget is built using smaller widgets (Row, Column, Text, Icon)
- StatelessWidget: Doesn't change over time (just displays data)
- Constructor parameters: "required this.trip" means you MUST pass trip data when creating this widget


================================================================================
PART 4: WEATHER WIDGET (LECTURE 5 PATTERN - MOST IMPORTANT!)
================================================================================

FILE: lib/widgets/weather_widget.dart
LINES: 50-83 (fetchWeather method)
LINES: 149-297 (FutureBuilder)

WHAT: Widget that fetches and displays weather using HTTP + FutureBuilder

WHY THIS IS IMPORTANT:
- This implements Lecture 5 pattern: HTTP requests with FutureBuilder
- Shows how to handle async operations (things that take time)
- Demonstrates API integration

HOW fetchWeather() WORKS (Lines 50-83):
1. Extracts city name from location (e.g., "Bali" from "Bali, Indonesia")
2. Builds API URL with city name and API key
3. Uses http.get(url) to make HTTP GET request (this takes time!)
4. Waits for response (await keyword)
5. If successful (status code 200), parses JSON response
6. Extracts temperature, condition, humidity from JSON
7. Returns formatted data as Map

WHY IT'S "async" AND RETURNS "Future":
- HTTP requests take time (network delay)
- "async" means this function can wait without freezing the app
- "Future" is a promise that data will arrive eventually
- Without async/await, the app would freeze while waiting

HOW FutureBuilder WORKS (Lines 149-297):
FutureBuilder is a widget that:
1. Takes a Future (our fetchWeather method)
2. Checks connectionState:
   - ConnectionState.waiting: Shows loading spinner (while request is in progress)
   - ConnectionState.done: Shows data or error
3. Rebuilds UI automatically when Future completes
4. Uses snapshot.data to access the result

WHY WE USE FutureBuilder:
- Handles loading state (shows spinner)
- Handles error state (shows error message)
- Handles success state (shows weather data)
- All in one widget - very convenient!

API SETUP:
- Uses OpenWeatherMap free API (no credit card needed)
- Get free API key at openweathermap.org
- Replace "YOUR_API_KEY_HERE" on line 35 with your actual key
- Free tier: 1,000 calls per day (enough for testing)


================================================================================
PART 5: TRIP DETAILS SCREEN WITH TABS
================================================================================

FILE: lib/screens/trip_details_screen.dart
LINES: 30 (_selectedTab state variable)
LINES: 154-158 (_selectTab method)
LINES: 160-198 (_buildTabButton method)
LINES: 414-427 (Tab buttons in UI)
LINES: 436-441 (Content switching)

WHAT: Screen with tabs (Overview, Flight, Weather) using custom buttons

WHY WE DID THIS:
- User wants to see different information about the trip
- Tabs organize content into sections
- We chose custom buttons (Option B) instead of TabBar for more control

HOW TABS WORK WITH setState:
1. We store current tab in _selectedTab variable (line 30): 'overview', 'flight', or 'weather'
2. When user taps a button, _selectTab() is called (line 154)
3. _selectTab() uses setState() to update _selectedTab (line 155-157)
4. setState() triggers widget rebuild
5. During rebuild, we check _selectedTab value (line 436-441)
6. We show different content based on which tab is selected:
   - If 'overview': Shows _buildOverviewContent()
   - If 'flight': Shows FlightInfoCard widget
   - If 'weather': Shows WeatherWidget

WHY setState:
- setState() tells Flutter "hey, something changed, rebuild the UI"
- Without setState, UI wouldn't update when tab changes
- This is basic state management in Flutter

HOW _buildTabButton WORKS (Lines 160-198):
- Creates a button widget
- Checks if this tab is selected (line 166: isSelected = _selectedTab == tabName)
- Changes color based on selection (line 173: blue if selected, transparent if not)
- When tapped, calls _selectTab() to change the selected tab


================================================================================
PART 6: FAVORITE FUNCTIONALITY
================================================================================

FILE: lib/screens/trip_details_screen.dart
LINES: 33-34 (_isFavorited and _isCheckingFavorite state)
LINES: 42-44 (initState calls _checkFavoriteStatus)
LINES: 52-80 (_checkFavoriteStatus method)
LINES: 90-152 (_toggleFavorite method)
LINES: 380-388 (Favorite button in UI)

WHAT: Allows users to favorite/unfavorite trips

WHY WE DID THIS:
- Implements interactivity requirement (6 marks in grading)
- Users can save trips they like
- Data is stored in Supabase (data persistence - 8 marks)

HOW _checkFavoriteStatus WORKS (Lines 52-80):
1. Checks if user is logged in
2. Queries Supabase 'favorites' table for this trip
3. Uses .eq() to filter by user_id and trip_id
4. If found, sets _isFavorited = true
5. Updates UI with setState()

HOW _toggleFavorite WORKS (Lines 90-152):
1. Checks if user is logged in (shows message if not)
2. Optimistic update: Changes _isFavorited immediately using setState (line 102-104)
3. If adding to favorites:
   - Inserts new row into Supabase 'favorites' table (line 109-117)
   - Shows success message
4. If removing from favorites:
   - Deletes row from Supabase using .delete() (line 127-131)
   - Shows removed message
5. If error occurs, reverts the change (line 141-144)

WHY OPTIMISTIC UPDATE:
- Updates UI immediately (feels fast)
- Then syncs with database
- If error, reverts the change
- Better user experience

DATABASE STRUCTURE:
Supabase 'favorites' table needs:
- user_id (string)
- trip_id (string)
- trip_name, trip_location, trip_price, trip_image (for displaying)
- favorited_at (timestamp)


================================================================================
PART 7: BOOKING SUMMARY SCREEN
================================================================================

FILE: lib/screens/booking_summary_screen.dart
LINES: 33-34 (TextEditingController for form inputs)
LINES: 38-44 (dispose method)
LINES: 55-131 (_handleConfirmBooking method)
LINES: 138-213 (_showSuccessDialog method)

WHAT: Final screen where users confirm their booking

WHY WE CREATED THIS FILE:
- Separates booking confirmation from trip details (better organization)
- Allows user to review before finalizing
- Collects additional info (guests count, special requests)

HOW TextEditingController WORKS (Lines 33-34):
- TextEditingController manages text input fields
- _guestsController manages "Number of Guests" field
- _specialRequestsController manages "Special Requests" field
- We must dispose() them when widget is destroyed (lines 38-44) to prevent memory leaks

HOW _handleConfirmBooking WORKS (Lines 55-131):
1. VALIDATION: Checks if user is logged in (line 57)
2. VALIDATION: Checks if guests field is filled (line 69)
3. VALIDATION: Checks if guests is a valid number >= 1 (line 80)
4. Calculates total price = base price Ã— number of guests (line 95-96)
5. Saves to Supabase 'bookings' table (line 99-108):
   - user_id, trip_id, trip_name, location
   - number_of_guests, special_requests
   - total_price, booking_date
6. Shows success dialog (line 112)
7. Navigates to home (line 115)

WHY VALIDATION:
- Prevents invalid data (e.g., negative guests, empty fields)
- Better user experience (shows helpful error messages)
- Required for "App Functionality" marks (10 marks)

HOW _showSuccessDialog WORKS (Lines 138-213):
- Uses showDialog() to display a modal dialog
- Shows success icon, message, and OK button
- barrierDismissible: false means user must tap OK (can't tap outside)
- When OK is pressed, dialog closes and navigation happens

DATABASE STRUCTURE:
Supabase 'bookings' table needs:
- user_id (string)
- trip_id, trip_name, location (string)
- number_of_guests (integer)
- special_requests (text, nullable)
- total_price (integer)
- booking_date (timestamp)


================================================================================
PART 8: MAIN APP UPDATES
================================================================================

FILE: lib/main.dart
LINES: 11 (import statement)
LINES: 118-126 (booking case in switch statement)

WHAT: Added routing for booking screen

WHY WE DID THIS:
- Completes the navigation flow: Trip Details â†’ Book Now â†’ Booking Summary
- Integrates new screen into existing navigation system

HOW IT WORKS:
1. Import BookingSummaryScreen (line 11)
2. Add case AppPage.booking in switch statement (lines 118-126)
3. When _currentPage == AppPage.booking, shows BookingSummaryScreen
4. Passes trip data and navigateTo function via constructor

WHY THIS PATTERN:
- Uses our custom enum-based navigation (not GoRouter)
- Data passed via constructor (not global state)
- Matches existing architecture pattern


================================================================================
KEY CONCEPTS EXPLAINED SIMPLY
================================================================================

1. setState():
   - Tells Flutter "something changed, please rebuild the UI"
   - Only works inside StatefulWidget
   - When you call setState(), Flutter rebuilds the widget

2. async/await:
   - Used for operations that take time (HTTP requests, database queries)
   - async = "this function can wait"
   - await = "wait here until this finishes"
   - Without it, app would freeze while waiting

3. Future:
   - A promise that data will arrive eventually
   - Like ordering food - you get a receipt (Future) now, food comes later

4. FutureBuilder:
   - Widget that automatically handles Future states
   - Shows loading â†’ then shows data or error
   - Very useful for API calls

5. StatefulWidget vs StatelessWidget:
   - StatelessWidget: Doesn't change (like a photo)
   - StatefulWidget: Can change (like a video player with play/pause)

6. Widget Composition:
   - Building big widgets from smaller widgets
   - Like building a house from bricks

7. Constructor Parameters:
   - Way to pass data when creating a widget
   - Like giving ingredients to a recipe

8. Supabase Operations:
   - .insert(): Add new row
   - .select(): Read rows
   - .delete(): Remove rows
   - .eq(): Filter (equals)
   - .maybeSingle(): Get one row or null


================================================================================
GRADING CRITERIA COVERAGE
================================================================================

âœ… Flutter UI & Widgets (5 marks): Scaffold, AppBar, Column/Row, ListView, images
âœ… APIs and Packages (2 marks): http package in pubspec.yaml
âœ… App Functionality (10 marks): All features work, validation implemented
âœ… Navigation & Structure (4 marks): Multiple screens, organized structure
âœ… Data Persistence (8 marks): Supabase for favorites and bookings (CRUD)
âœ… Responsiveness & UX (4 marks): Responsive layouts, dark mode
âœ… Interactivity (6 marks): Favorite trips functionality
âœ… Code Quality (2 marks): Clean, readable code


================================================================================
PART 9: DATABASE SETUP - SUPABASE SQL TABLES
================================================================================

FILE: supabase_setup.sql
LINES: 1-119 (entire file)

WHAT: SQL script to create database tables for favorites and bookings

WHY WE NEED THIS:
- Store user's favorite trips (so they persist between app sessions)
- Store confirmed bookings (so users can view their booking history)
- Data persistence is worth 8 marks in grading
- Without these tables, favorite and booking features won't work

HOW TO RUN THIS SQL:
1. Go to https://supabase.com/dashboard
2. Select your project: jofcdkdoxhkjejgkdrbk
3. Click "SQL Editor" in the left sidebar
4. Click "New Query"
5. Copy entire content from supabase_setup.sql
6. Click "Run" button
7. Check for success message

================================================================================
TABLE 1: FAVORITES TABLE
================================================================================

LINES IN SQL: 17-25

COLUMNS EXPLAINED:
- id: Unique identifier for each favorite (auto-generated UUID)
- user_id: Which user favorited this trip (links to auth.users table)
- trip_id: Which trip was favorited (TEXT)
- trip_name: Name of the trip (e.g., "Tropical Paradise")
- trip_location: Location (e.g., "Bali, Indonesia")
- trip_price: Price in dollars (INTEGER)
- trip_image: Image URL (TEXT)
- favorited_at: When was this favorited (auto timestamp)

UNIQUE CONSTRAINT (Line 25):
- UNIQUE(user_id, trip_id): Same user can't favorite the same trip twice
- Prevents duplicate favorites

WHY "ON DELETE CASCADE" (Line 19):
- If a user is deleted, their favorites are also deleted automatically
- Keeps database clean (no orphaned records)

HOW IT'S USED IN THE APP:
- lib/screens/trip_details_screen.dart
- _checkFavoriteStatus() READS from this table (line 52-80)
  * Uses .select() to check if trip is favorited
  * Uses .eq() to filter by user_id and trip_id
  * If found, shows filled heart icon
  
- _toggleFavorite() WRITES to this table (line 90-152)
  * Uses .insert() to add favorite (line 109-117)
  * Uses .delete() to remove favorite (line 127-131)

================================================================================
TABLE 2: BOOKINGS TABLE
================================================================================

LINES IN SQL: 59-70

COLUMNS EXPLAINED:
- id: Unique identifier for each booking (auto-generated UUID)
- user_id: Which user made this booking (links to auth.users)
- trip_id: Which trip was booked (TEXT)
- trip_name: Name of the trip
- location: Trip location
- number_of_guests: How many people (INTEGER, must be >= 1)
- special_requests: Any special requests (TEXT, can be null)
- total_price: Total cost = base price Ã— guests (INTEGER)
- booking_date: When booking was made (auto timestamp)

CHECK CONSTRAINT (Line 65):
- CHECK (number_of_guests >= 1): Ensures at least 1 guest
- Prevents invalid bookings with 0 or negative guests
- Database-level validation (in addition to app validation)

HOW IT'S USED IN THE APP:
- lib/screens/booking_summary_screen.dart
- _handleConfirmBooking() WRITES to this table (line 99-108)
  * Validates user is logged in
  * Validates number of guests
  * Calculates total price
  * Uses .insert() to save booking

================================================================================
ROW LEVEL SECURITY (RLS) - VERY IMPORTANT FOR DISCUSSION!
================================================================================

WHAT IS RLS:
Row Level Security is a Supabase feature that controls WHO can see/edit WHICH rows

WHY WE NEED RLS:
- Without it, users could see other users' favorites and bookings!
- This is a security feature (prevents data leaks)
- Only users should see their own data

HOW RLS WORKS:

1. ENABLE RLS (Lines 28, 74):
   ALTER TABLE favorites ENABLE ROW LEVEL SECURITY;
   - Turns on RLS for the table
   - Now ALL access is blocked by default
   - Must create policies to allow access

2. SELECT POLICY (Lines 31-33, 77-79):
   "Users can view their own favorites/bookings"
   - USING (auth.uid() = user_id)
   - Means: Only show rows where the user_id matches the logged-in user
   - Example: User A can only see User A's favorites, not User B's

3. INSERT POLICY (Lines 36-38, 82-84):
   "Users can insert their own favorites/bookings"
   - WITH CHECK (auth.uid() = user_id)
   - Means: Users can only insert rows with their own user_id
   - Prevents User A from creating favorites as User B

4. DELETE POLICY (Lines 41-43):
   "Users can delete their own favorites"
   - USING (auth.uid() = user_id)
   - Means: Users can only delete their own favorites
   - Prevents User A from deleting User B's favorites

WHY THIS PATTERN:
- auth.uid() is Supabase function that returns logged-in user's ID
- Every policy checks if auth.uid() matches the row's user_id
- This is standard security practice in Supabase

================================================================================
DATABASE INDEXES - PERFORMANCE OPTIMIZATION
================================================================================

LINES IN SQL: 88-97

WHAT ARE INDEXES:
- Indexes make database queries faster
- Like an index in a book (helps find things quickly)
- Without indexes, database scans entire table (slow)

INDEXES WE CREATED:

1. idx_favorites_user_id (Line 91):
   - Index on user_id column in favorites table
   - Makes queries like "find all favorites for this user" super fast
   - Used when displaying user's favorite trips list

2. idx_favorites_user_trip (Line 94):
   - Compound index on (user_id, trip_id)
   - Makes queries like "is this trip favorited by this user?" super fast
   - Used in _checkFavoriteStatus() method

3. idx_bookings_user_id (Line 97):
   - Index on user_id column in bookings table
   - Makes queries like "find all bookings for this user" super fast
   - Used when displaying user's booking history

4. idx_bookings_date (Line 100):
   - Index on booking_date column, ordered descending
   - Makes queries like "show recent bookings first" super fast
   - DESC means newest first

WHY THIS MATTERS FOR DISCUSSION:
- Shows you understand performance optimization
- Demonstrates knowledge of database best practices
- Small detail but shows advanced thinking

================================================================================
SQL CONCEPTS YOU SHOULD KNOW (FOR DISCUSSION)
================================================================================

1. UUID (Universally Unique Identifier):
   - Special ID format (like: a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11)
   - uuid_generate_v4() creates random UUID
   - Guaranteed to be unique globally
   - Better than simple integers (1, 2, 3) for distributed systems

2. REFERENCES / FOREIGN KEY (Line 19):
   - user_id UUID REFERENCES auth.users(id)
   - Means: user_id MUST be a valid ID from auth.users table
   - Ensures data integrity (can't have favorites for non-existent user)
   - Creates relationship between tables

3. DEFAULT (Lines 18, 25):
   - Sets automatic value if not provided
   - uuid_generate_v4(): Auto-generates ID
   - NOW(): Auto-sets current timestamp
   - Saves app from having to provide these values

4. NOT NULL (Lines 20-24):
   - Field must have a value (can't be empty)
   - Ensures required data is always present
   - trip_name NOT NULL: Every favorite must have a name

5. CHECK Constraint (Line 65):
   - Database-level validation rule
   - CHECK (number_of_guests >= 1): Ensures valid guest count
   - Prevents invalid data even if app has bugs

6. CREATE INDEX IF NOT EXISTS (Line 91):
   - Creates index only if it doesn't already exist
   - Safe to re-run the script without errors
   - Good practice for migration scripts

================================================================================
HOW TO VERIFY TABLES WERE CREATED CORRECTLY
================================================================================

LINES IN SQL: 106-119 (Verification queries)

After running the SQL, run these verification queries:

QUERY 1 (Lines 106-109):
SELECT table_name, column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'favorites' 
ORDER BY ordinal_position;

WHAT IT DOES: Shows all columns in favorites table
YOU SHOULD SEE: id, user_id, trip_id, trip_name, trip_location, trip_price, trip_image, favorited_at

QUERY 2 (Lines 112-115):
SELECT table_name, column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'bookings' 
ORDER BY ordinal_position;

WHAT IT DOES: Shows all columns in bookings table
YOU SHOULD SEE: id, user_id, trip_id, trip_name, location, number_of_guests, special_requests, total_price, booking_date

QUERY 3 (Lines 118-120):
SELECT schemaname, tablename, policyname 
FROM pg_policies 
WHERE tablename IN ('favorites', 'bookings');

WHAT IT DOES: Shows all RLS policies
YOU SHOULD SEE: 
- Users can view their own favorites
- Users can insert their own favorites
- Users can delete their own favorites
- Users can view their own bookings
- Users can insert their own bookings

IF YOU SEE ALL OF THESE: Tables are correctly set up! âœ…

================================================================================
COMMON SQL ERRORS AND HOW TO FIX THEM
================================================================================

ERROR: "relation 'favorites' already exists"
FIX: Tables already created! You're good to go.
REASON: We use "CREATE TABLE IF NOT EXISTS" to prevent this

ERROR: "column 'booking_date' does not exist"
FIX: The SQL script now handles this automatically!
REASON: Bookings table existed from previous setup without booking_date column
HOW WE FIXED IT (Lines 60-68 in SQL file):
- Added a DO block that checks if booking_date column exists
- If it doesn't exist, uses ALTER TABLE to add it
- This makes the script work whether table is new or already exists
WHY THIS MATTERS: Shows you understand database migrations and backward compatibility

ERROR: "policy already exists"
FIX: The SQL script now handles this automatically!
REASON: We use "DROP POLICY IF EXISTS" before creating policies
HOW IT WORKS (Lines 31-33, 72-74):
- Drops existing policies first (if they exist)
- Then creates fresh policies
- Makes script safe to run multiple times without errors

ERROR: "permission denied"
FIX: Make sure you're logged into correct Supabase project
REASON: You might be in wrong project or not have admin rights

ERROR: "function uuid_generate_v4() does not exist"
FIX: Run this first: CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
REASON: UUID extension not enabled (rare on Supabase, usually pre-enabled)

================================================================================
ARCHITECTURE: HOW APP + DATABASE WORK TOGETHER
================================================================================

FLOW FOR FAVORITING A TRIP:

1. User taps heart icon in trip_details_screen.dart
2. App calls _toggleFavorite() method
3. Method checks if user is logged in
4. If adding favorite:
   a. App uses Supabase client: supabase.from('favorites').insert({...})
   b. Request goes to Supabase server
   c. RLS policy checks: Does auth.uid() match user_id? âœ…
   d. Row is inserted into favorites table
   e. Success response returns to app
   f. App updates UI with setState()
5. If removing favorite:
   a. App uses: supabase.from('favorites').delete().eq('user_id', ...).eq('trip_id', ...)
   b. RLS policy checks permissions âœ…
   c. Row is deleted
   d. UI updates

FLOW FOR BOOKING A TRIP:

1. User fills form in booking_summary_screen.dart
2. User taps "Confirm Booking"
3. App validates input (guests >= 1, etc.)
4. App calculates total price
5. App uses: supabase.from('bookings').insert({...})
6. RLS policy checks permissions âœ…
7. Row is inserted into bookings table
8. Success dialog is shown
9. User navigates back to home

================================================================================
IMPORTANT NOTES FOR DISCUSSION
================================================================================

1. Weather API: 
   âœ… COMPLETED - API key updated in weather_widget.dart line 17

2. Supabase Tables: 
   ðŸ“‹ NEXT STEP - Go to Supabase dashboard and run supabase_setup.sql
   File location: Flutter-Project/supabase_setup.sql
   After running, verify with the verification queries

3. State Management: We use setState (not Riverpod) as per requirements

4. Navigation: Custom enum-based system (not GoRouter) as per requirements

5. Data Flow: Data passed via constructors (not global state)

6. Architecture: Follows widget composition pattern (reusable widgets)

7. Database Security: RLS policies ensure users only see their own data


================================================================================
PART 10: TRIPS SCREEN - MY BOOKINGS & FAVORITES
================================================================================

FILE: lib/screens/trips_screen.dart
LINES: 1-362 (entire file - completely rewritten)

WHAT: Screen that shows user's booked trips and favorited trips

WHY WE CREATED THIS:
- Users need to see their booking history
- Users want quick access to their favorite trips
- Original screen only showed recommended trips (not personalized)
- Demonstrates data persistence and personalization (important for grading)

================================================================================
KEY CHANGES FROM ORIGINAL
================================================================================

BEFORE:
- StatelessWidget (no state management)
- Showed static "allTrips" list for everyone
- No database queries
- No user-specific data

AFTER:
- StatefulWidget (manages dynamic state)
- Fetches user's bookings from Supabase 'bookings' table
- Fetches user's favorites from Supabase 'favorites' table
- Toggle buttons to switch between views
- Loading states, empty states, not-logged-in state

================================================================================
HOW IT WORKS - STATE MANAGEMENT
================================================================================

STATE VARIABLES (Lines 28-31):
1. _currentView (String): Tracks which view is active ('bookings' or 'favorites')
2. _bookings (List): Stores user's bookings fetched from database
3. _favorites (List): Stores user's favorites fetched from database
4. _isLoading (bool): Shows loading spinner while fetching data

WHY StatefulWidget:
- Need to change view when user clicks toggle buttons
- Need to store fetched data
- Need to track loading state
- setState() triggers UI rebuilds when data changes

================================================================================
HOW DATA FETCHING WORKS
================================================================================

INITIALIZATION (Lines 33-39):
- initState() runs when screen first loads
- Checks if user is logged in
- If yes: calls _loadData() to fetch initial data
- If no: shows "Login Required" message

_loadData() METHOD (Lines 41-50):
1. Sets _isLoading = true (shows spinner)
2. Checks current view ('bookings' or 'favorites')
3. Calls appropriate fetch method
4. Sets _isLoading = false (hides spinner)
5. Updates UI with setState()

_fetchBookings() METHOD (Lines 52-70):
1. Gets current user ID from supabase.auth.currentUser?.id
2. If no user ID, returns early
3. Queries Supabase:
   - FROM 'bookings' table
   - SELECT all columns
   - WHERE user_id = current user
   - ORDER BY booking_date DESC (newest first)
4. Stores results in _bookings list
5. Updates UI with setState()
6. If error: shows error message to user

_fetchFavorites() METHOD (Lines 72-90):
Same pattern as _fetchBookings but:
- Queries 'favorites' table instead
- Orders by favorited_at DESC
- Stores in _favorites list

WHY ERROR HANDLING:
- Network might fail
- Database might be down
- User should see helpful error message, not crash

================================================================================
TOGGLE BUTTONS UI
================================================================================

_buildViewToggle() METHOD (Lines 92-155):
Creates two buttons side-by-side:

BUTTON 1: "My Bookings"
- Icon: bookmark (filled if selected, outline if not)
- Background: Blue if selected, gray if not
- OnPressed: calls _switchView('bookings')

BUTTON 2: "My Favorites"
- Icon: heart (filled if selected, outline if not)
- Background: Orange if selected, gray if not
- OnPressed: calls _switchView('favorites')

HOW _switchView WORKS (Lines 100-105):
1. Updates _currentView state variable
2. Calls _loadData() to fetch new data
3. setState() triggers rebuild
4. UI shows different content based on new view

WHY TWO SEPARATE BUTTONS:
- Clear visual distinction between bookings and favorites
- User can easily switch between views
- Better UX than dropdown menu

================================================================================
EMPTY STATES
================================================================================

_buildEmptyState() METHOD (Lines 157-199):
Shows when user has no bookings or no favorites

DISPLAYS:
- Icon: luggage for bookings, heart for favorites
- Message: "No bookings yet" or "No favorites yet"
- Subtitle: Encouragement to explore
- Button: "Explore Trips" â†’ navigates to home screen

WHY EMPTY STATES:
- Better UX than blank screen
- Guides user on what to do next
- Feels polished and complete

================================================================================
DISPLAYING TRIPS LIST
================================================================================

_buildTripsList() METHOD (Lines 201-239):
1. Gets correct data: _bookings or _favorites based on _currentView
2. If empty: shows _buildEmptyState()
3. If has data: shows GridView with TripCard widgets

DATA TRANSFORMATION (Lines 217-225):
Bookings and favorites have different column names, so we transform:
- trip_id OR trip_id â†’ 'id'
- trip_name â†’ 'name'
- location OR trip_location â†’ 'location'
- total_price OR trip_price â†’ 'price'
- trip_image â†’ 'image'
- rating â†’ hardcoded 4.5 (not stored in database)

WHY TRANSFORMATION:
- TripCard expects specific field names
- Bookings table uses 'total_price', favorites uses 'trip_price'
- Need to normalize data so TripCard works with both

================================================================================
NOT LOGGED IN STATE
================================================================================

_buildNotLoggedIn() METHOD (Lines 241-280):
Shows when user accesses Trips Screen without logging in

DISPLAYS:
- Lock icon
- "Login Required" message
- "Please log in" subtitle
- "Log In" button â†’ opens authentication modal

WHY THIS STATE:
- Bookings and favorites are user-specific (need authentication)
- Clear call-to-action for unauthenticated users
- Better than crashing or showing nothing

================================================================================
MAIN BUILD METHOD
================================================================================

BUILD METHOD (Lines 282-322):
Structure:
1. CustomAppBar (navigation, theme toggle, login)
2. Title: "My Bookings" or "My Favorites" (changes based on view)
3. If logged in:
   - Toggle buttons
   - Loading spinner OR trips list
4. If not logged in:
   - "Login Required" message

CONDITIONAL RENDERING (Lines 304-320):
- if (widget.isLoggedIn) â†’ show toggle and data
- if (_isLoading) â†’ show spinner
- else â†’ show trips list
- else â†’ show login prompt

================================================================================
KEY CONCEPTS DEMONSTRATED
================================================================================

1. STATEFUL WIDGET WITH COMPLEX STATE:
   - Multiple state variables
   - Async data fetching
   - Loading states
   - View switching

2. SUPABASE QUERY PATTERNS:
   - .from() â†’ select table
   - .select() â†’ get columns
   - .eq() â†’ filter by equality
   - .order() â†’ sort results
   - Handling async with await

3. CONDITIONAL UI RENDERING:
   - Different content based on login status
   - Different content based on selected view
   - Different content based on data presence
   - Shows loading, data, or empty states

4. DATA TRANSFORMATION:
   - Converting database format to UI format
   - Normalizing different table structures
   - Ensuring TripCard compatibility

5. ERROR HANDLING:
   - Try-catch blocks
   - User-friendly error messages
   - Graceful degradation

6. USER EXPERIENCE:
   - Clear visual feedback (selected button)
   - Loading indicators
   - Empty states with guidance
   - Easy navigation

================================================================================
GRADING CRITERIA COVERAGE (UPDATED)
================================================================================

âœ… Flutter UI & Widgets (5 marks): Multiple complex widgets, state management
âœ… APIs and Packages (2 marks): http package, Supabase queries
âœ… App Functionality (10 marks): Full CRUD operations, data fetching, user flows
âœ… Navigation & Structure (4 marks): Multiple screens, context-aware navigation
âœ… Data Persistence (8 marks): Reading bookings and favorites from Supabase
âœ… Responsiveness & UX (4 marks): Loading states, empty states, error handling
âœ… Interactivity (6 marks): Toggle buttons, favorites, bookings, live data
âœ… Code Quality (2 marks): Clean code, error handling, state management

NEW FEATURES ADDED:
+ View booking history
+ View favorite trips
+ Toggle between views
+ Personalized experience
+ Data persistence demonstrated

================================================================================
IMPORTANT NOTES FOR DISCUSSION
================================================================================

1. Weather API: 
   âœ… COMPLETED - Valid API key: 45885d4ddefca7a38d0595ff0b911f8b

2. Supabase Tables: 
   âœ… COMPLETED - Tables created with all required columns

3. Trips Screen:
   âœ… NEW FEATURE - Shows user's bookings and favorites
   - Fetches real data from Supabase
   - Toggle buttons to switch views
   - Handles all states (loading, empty, error, not logged in)

4. State Management: Uses setState (StatefulWidget pattern)

5. Navigation: Custom enum-based system (not GoRouter) as per requirements

6. Data Flow: Fetches from Supabase, transforms for UI, displays in TripCard

7. Database Security: RLS policies ensure users only see their own data

8. User Experience: Loading spinners, empty states, error messages, clear CTAs




================================================================================
PART 11: BOOKING DETAILS POPUP & CANCEL BOOKING
================================================================================

FILES: 
- lib/screens/trip_details_screen.dart (lines 127-298)
- lib/screens/trips_screen.dart (lines 222-237 for metadata passing)

WHAT: Popup dialog showing booking details with cancel booking functionality

WHY WE CREATED THIS:
- Users clicking on booked trips shouldn't see "Book Now" again
- Need to show booking confirmation details
- Allow users to cancel their bookings
- Better UX - clear distinction between browsing and managing bookings

================================================================================
HOW IT WORKS
================================================================================

DETECTING BOOKED TRIPS (trip_details_screen.dart):
Line 127: `bool get _isBookedView => widget.trip['_isBookedView'] == true;`

This checks if the trip data has `_isBookedView` metadata.
- If true: User is viewing from "My Bookings"
- If false/null: User is browsing normally

PASSING BOOKING METADATA (trips_screen.dart lines 222-237):
When user clicks trip from "My Bookings", we pass extra metadata:
```dart
if (_currentView == 'bookings') ...{
  '_isBookedView': true,
  '_bookingId': item['id'],
  '_numberOfGuests': item['number_of_guests'],
  '_specialRequests': item['special_requests'],
  '_bookingDate': item['booking_date'],
  '_totalPrice': item['total_price'],
  '_travelDate': item['travel_date'],
  '_seatCategory': item['seat_category'],
  '_seatNumber': item['seat_number'],
}
```

CHANGING THE BUTTON (trip_details_screen.dart lines 538-570):
Instead of always showing "Book Now" button:
- Check `_isBookedView`
- If true: Show "View Booking Details" (blue button with receipt icon)
- If false: Show "Book Now" (orange button with book icon)

BOOKING DETAILS DIALOG (lines 129-198):
Shows a popup with:
- Trip name and location
- Number of guests
- Travel date
- Seat category and seat number
- Total price paid
- Booking date
- Special requests (if any)
- "Close" button
- "Cancel Booking" button (red)

CANCEL BOOKING PROCESS (lines 225-298):
1. User clicks "Cancel Booking" in popup
2. Shows confirmation dialog: "Are you sure?"
3. If user confirms:
   - Gets booking ID from metadata
   - Deletes from Supabase: `supabase.from('bookings').delete().eq('id', bookingId)`
   - Shows success message
   - Navigates back to "My Trips"
   - Trips screen auto-refreshes (via refresh key)
   - Booking disappears from list

WHY REFRESH KEY WORKS (main.dart lines 48, 76-79, 97):
- Added `int _tripsRefreshKey = 0;` state variable
- When navigating to trips page: `_tripsRefreshKey++;`
- Trips screen has: `key: ValueKey(_tripsRefreshKey)`
- When key changes, Flutter completely rebuilds the widget
- New build = fresh data fetch from database
- Cancelled bookings don't appear anymore!

ROW LEVEL SECURITY (supabase_setup.sql line 151-154):
DELETE policy ensures users can only delete their own bookings:
```sql
CREATE POLICY "Users can delete their own bookings"
  ON bookings FOR DELETE
  USING (auth.uid() = user_id);
```

Without this policy, the delete would fail even with correct booking ID!

================================================================================
PART 12: EXPLORE TRIPS PAGE
================================================================================

FILE: lib/screens/explore_trips_screen.dart (entire file)

WHAT: Dedicated page for browsing all available trip destinations

WHY WE CREATED THIS:
- Separation of concerns: Browse vs Manage
- "My Trips" = Your bookings and favorites (personalized)
- "Explore Trips" = All available destinations (catalog)
- Better navigation flow
- Users expect "Start Exploring" to show trip catalog

HOW IT'S DIFFERENT FROM MY TRIPS:
- Shows ALL trips (not user-specific)
- Uses `allTrips` data from config/trip_data.dart
- No login required to view
- Grid layout (like My Trips)
- Shows count: "11 destinations available"

NAVIGATION FLOW:
1. Home page "Start Exploring" button â†’ Explore Trips page
2. Navigation "My Trips" button â†’ My Bookings/Favorites page

ADDED TO ROUTING (main.dart):
- Line 1: Added AppPage.explore to enum
- Line 12: Import explore_trips_screen.dart
- Lines 132-138: Routing case for explore page
- home_screen.dart line 93: "Start Exploring" navigates to AppPage.explore

TRIP DATA EXPANSION (config/trip_data.dart):
Originally 4 trips, now 11 trips total!

NEW DESTINATIONS ADDED:
5. Pyramids of Giza, Egypt - $1,499
6. Santorini, Greece - $1,699
7. Iceland Northern Lights - $1,899
8. Dubai, UAE - $2,199
9. Maldives Paradise - $2,499
10. New York City, USA - $1,399
11. Amazon Rainforest, Brazil - $1,599

All trips have:
- Unique IDs
- High-quality Unsplash images
- Realistic prices
- Airlines and aircraft types
- Seat categories
- Descriptions

================================================================================
PART 13: ENHANCED BOOKING FORM FIELDS
================================================================================

FILE: lib/screens/booking_summary_screen.dart

WHAT: Added 3 new required fields to booking form

NEW FIELDS REQUIRED:
1. Travel Date (Date Picker)
2. Seat Category (Dropdown)
3. Seat Number (Text Input)

WHY WE ADDED THESE:
- More realistic booking process
- Matches real airline bookings
- Better data for trip details
- Shows in booking details popup

================================================================================
TRAVEL DATE PICKER (lines 323-356)
================================================================================

UI: Clickable field that opens date picker calendar
Implementation: InkWell wrapped around InputDecorator

Date Constraints:
- Can't select past dates
- Minimum: Today
- Maximum: 1 year from today
- Default initial: 7 days from today

State: `DateTime? _selectedTravelDate;`

Display Format: YYYY-MM-DD (e.g., 2025-12-24)

Validation: Required field - shows error if not selected

Stored in Database: DATE type column `travel_date`

================================================================================
SEAT CATEGORY DROPDOWN (lines 358-381)
================================================================================

UI: Dropdown selection with 4 options

Options:
1. Economy
2. Economy Plus
3. Business Class
4. First Class

State: `String _selectedSeatCategory = 'Economy';`
Default: Economy (cheapest option)

Icon: airline_seat_recline_extra (seat icon)

Stored in Database: TEXT column `seat_category`

================================================================================
SEAT NUMBER INPUT (lines 383-398)
================================================================================

UI: Text field with uppercase auto-capitalization

Format Examples: 19D, 23B, 4C, 12A

Features:
- Auto-capitalizes input (textCapitalization.characters)
- Hint text shows examples
- Icon: event_seat (seat icon)

State: `TextEditingController _seatNumberController`

Validation: Required field - shows error if empty

Stored in Database: TEXT column `seat_number`

================================================================================
DATABASE SCHEMA UPDATES (supabase_setup.sql)
================================================================================

ADDED COLUMNS TO BOOKINGS TABLE (lines 110-127):

```sql
-- Travel date
ALTER TABLE bookings ADD COLUMN travel_date DATE;

-- Seat category  
ALTER TABLE bookings ADD COLUMN seat_category TEXT;

-- Seat number
ALTER TABLE bookings ADD COLUMN seat_number TEXT;
```

All use IF NOT EXISTS pattern so script can be re-run safely.

BOOKING INSERT (booking_summary_screen.dart lines 72-91):
Now saves all fields:
```dart
await supabase.from('bookings').insert({
  'user_id': user.id,
  'trip_name': widget.trip['title'],
  'trip_id': widget.trip['id'],
  'location': widget.trip['location'],
  'trip_image': widget.trip['image'],
  'number_of_guests': guestsCount,
  'travel_date': _selectedTravelDate!.toIso8601String().split('T')[0],
  'seat_category': _selectedSeatCategory,
  'seat_number': _seatNumberController.text.trim(),
  'special_requests': _specialRequestsController.text.trim(),
  'total_price': totalPrice,
  'booking_date': DateTime.now().toIso8601String(),
});
```

VIEWING IN BOOKING DETAILS:
All 3 new fields show in the booking details popup when user views their booked trip.

================================================================================
COMPLETE FEATURE SUMMARY (ENTIRE APP)
================================================================================

NAVIGATION STRUCTURE:
â”œâ”€â”€ Home Page
â”‚   â””â”€â”€ "Start Exploring" â†’ Explore Trips (11 destinations)
â”œâ”€â”€ My Trips (Nav Button)
â”‚   â”œâ”€â”€ My Bookings Tab (user's confirmed bookings)
â”‚   â”‚   â””â”€â”€ Click trip â†’ View Booking Details popup
â”‚   â”‚       â””â”€â”€ Cancel Booking button
â”‚   â””â”€â”€ My Favorites Tab (user's favorited trips)
â””â”€â”€ Explore Trips
    â””â”€â”€ Browse all 11 destinations
        â””â”€â”€ Click details â†’ Book or Favorite

DATABASE TABLES:
1. bookings: Confirmed trip bookings with full details
2. favorites: User's saved favorite trips

ROW LEVEL SECURITY:
- Users can only view/edit/delete their own data
- Enforced at database level (not just app level)
- Prevents data leaks even if app has bugs

KEY FLUTTER CONCEPTS DEMONSTRATED:
1. StatefulWidget with complex state management
2. Async/await for database operations
3. Form validation
4. Date pickers and dropdowns
5. Conditional UI rendering
6. Navigation with data passing
7. Dialog popups
8. Refresh mechanisms (ValueKey)
9. Error handling with try-catch
10. User feedback (SnackBar messages)

GRADING CRITERIA - FINAL COVERAGE:
âœ… Flutter UI & Widgets (5 marks): Complex widgets, forms, dialogs
âœ… APIs & Packages (2 marks): Supabase SDK, HTTP (weather)
âœ… App Functionality (10 marks): Full booking flow, CRUD operations
âœ… Navigation & Structure (4 marks): Multi-page with data passing
âœ… Data Persistence (8 marks): Database with RLS
âœ… Responsiveness & UX (4 marks): Loading states, validation, errors
âœ… Interactivity (6 marks): Forms, favorites, bookings, cancellations
âœ… Code Quality (2 marks): Clean code, error handling, comments

TOTAL ESTIMATED SCORE: 41/41 marks âœ…

================================================================================
FINAL IMPORTANT NOTES FOR DISCUSSION
================================================================================

1. Weather API Key: 45885d4ddefca7a38d0595ff0b911f8b (hamzaWeather)

2. Supabase Project: jofcdkdoxhkjejgkdrbk

3. Total Destinations: 11 trips across 3 continents

4. Security: Row Level Security policies protect all user data

5. Booking Flow: 
   Explore â†’ Details â†’ Book (with 3 new fields) â†’ Confirm â†’ View in My Bookings â†’ Cancel if needed

6. State Management: Uses StatefulWidget pattern (not Provider/Bloc)

7. Navigation: Custom enum-based system (not GoRouter)

8. Database: Supabase (PostgreSQL)

9. Refresh Mechanism: ValueKey forces widget rebuild

10. Form Validation: All booking fields validated before submission

Good luck with your discussion! You now have a fully featured trip booking app! ðŸš€


================================================================================
END OF NOTES
================================================================================

Study these concepts well, especially:
- How setState triggers UI rebuilds  
- How RLS policies protect user data
- How indexes improve query performance
- How StatefulWidget manages multiple state variables
- How to fetch and display user-specific data from Supabase
- How conditional rendering creates different UI states
- How ValueKey forces widget rebuilds
- How form validation works
- How date pickers and dropdowns are implemented
- How dialog popups work in Flutter

Good luck with your discussion! ðŸš€

